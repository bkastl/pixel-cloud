<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Pixel Cloud</title>
	<style>
		html, body {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		rect {
			cursor: pointer;
			fill: currentColor;
			stroke: currentColor;
			stroke-width: 0;
			transition: all 0.25s;
		}
		rect:hover {
			stroke-width: 10px;
			z-index: 99;
		}
	</style>
</head>
<body>
	<div id="stage"></div>
	<script>

		/*Daten menge checken und daraus die minimale Größe ableiten*/

		/* Wenn Datengröße größer als min Partikel Size > Canvas entsprechend skalieren*/

		function shuffleArray(array) {
    		for (var i = array.length - 1; i > 0; i--) {
        		var j = Math.floor(Math.random() * (i + 1));
        		var temp = array[i];
        		array[i] = array[j];
        		array[j] = temp;
    		}

    		return array;
		}

		function generateUID() {
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
			var uid = '';

			for (var i=0; i<32; i++) {
				uid += chars.charAt(Math.round(Math.random()*(chars.length-1)));
			}
	
			return uid;
		}

		function getRandomColorHex() {
			var letters = '0123456789ABCDEF'.split('');
			var color = '#';
			for (var i = 0; i < 6; i++ ) {
				color += letters[Math.round(Math.random() * 15)];
			}
			return color;
		}

		function getRandomRGBString() {
 			var o = Math.round, r = Math.random, s = 255;
    		return o(r()*s) + ',' + o(r()*s) + ',' + o(r()*s);
		}

		var minimumParticleSize = 32;
		var maximumParticleSize = window.innerWidth / 10;

		var currentParticleSize = minimumParticleSize;

		var animationDuration = 240; //animation duration in frames

		var canvas;
		var context;
		var stage = document.getElementById('stage');
		var stageWidth = window.innerWidth;
		var stageHeight = window.innerHeight;

		var rowsMax;
		var rowsMin;
		var colsMax;
		var rowsMax;

		stageWidth = window.innerWidth + currentParticleSize / 2;
		stageHeight = window.innerHeight + currentParticleSize / 2;
		
		var dataArray = [];
		var animateArray = [];
		var dataPositionObject = {};
		var tick;
		var startAnimationFrame = 0;

		function buildCanvas() {
			var canvas = document.createElement("canvas");
				canvas.id = "canvas";
				canvas.setAttribute("width", stageWidth);
				canvas.setAttribute("height", stageHeight);
				stage.appendChild(canvas);
				context = canvas.getContext("2d");
				backingStoreRatio = context.webkitBackingStorePixelRatio ||
                            context.mozBackingStorePixelRatio ||
                            context.msBackingStorePixelRatio ||
                            context.oBackingStorePixelRatio ||
                            context.backingStorePixelRatio || 1,

        		ratio = devicePixelRatio / backingStoreRatio;

        		if (devicePixelRatio !== backingStoreRatio) {
        			var oldWidth = canvas.width;
        			var oldHeight = canvas.height;

        			canvas.width = oldWidth * ratio;
        			canvas.height = oldHeight * ratio;

			        canvas.style.width = oldWidth + 'px';
        			canvas.style.height = oldHeight + 'px';
        			context.scale(ratio, ratio);
        		}
        		stage.style.marginLeft = "-" + currentParticleSize / 2 + "px";
        		stage.style.marginTop = "-" + currentParticleSize / 2 + "px";

		}

		function prefillArray(count) {
			var dataArray = {};
			var i = 0;
			while (i < count) {
				dataArray[i] = {};
				dataArray[i].color = getRandomRGBString();
				dataArray[i].id = i;
				dataArray[i].speed = Math.random() * (animationDuration/2000 - 0);
				dataArray[i].title = "particle" + i;
				dataArray[i].message = generateUID();

				++i;
			}

			return dataArray;
		}

		function generateSlots(max) {
			var arr = [];

			var i = 0;

			rowsMax = Math.ceil(stageHeight / minimumParticleSize);
			colsMax = Math.ceil(stageWidth / minimumParticleSize);
			rowsMin = Math.ceil(stageHeight / maximumParticleSize);
			colsMin = Math.ceil(stageWidth / maximumParticleSize);
		
			while (i < rowsMax) {
				var j = 0;
				while (j < colsMax) {
					var element = [j, i];
					arr.push(element);
					++j;
				}
				++i;
			}

			console.log(arr.length)

			return arr;
		}

		function fillStage(arr) {

			if (arr === undefined) {
				arr = prefillArray(2500);
			}
			var placementArray = generateSlots(arr.length);
			placementArray = shuffleArray(placementArray);


			var i = 0;
			while (i < placementArray.length) {


				var position = placementArray[i];
				
				var posX = position[0];
				var posY = position[1];

				var slot;

				slot = arr[i];
				if (slot !== undefined) {
					placementArray[i].push(slot.id);
					dataPositionObject[posX + "." + posY] = slot.id;
				}
				if (slot !== undefined) {
					renderParticle(posX, posY, currentParticleSize, slot.color, 0);
					animateArray.push([posX, posY, slot.color, slot.speed]);
				}
				++i;
			}

		}

		function animateStage() {

			tick = requestAnimationFrame(innerTick);
			
		}

		function innerTick() {
			var j = 0;
			context.clearRect(0, 0, stageWidth, stageHeight);	
			while (j < animateArray.length) {
				renderParticle(animateArray[j][0], animateArray[j][1], currentParticleSize, animateArray[j][2], 0+animateArray[j][3]*startAnimationFrame, 1);
				++j;
			}
			++startAnimationFrame;
			if (startAnimationFrame < animationDuration) {
				tick = requestAnimationFrame(innerTick);
			}
			else {
				cancelAnimationFrame(tick);
				tick = null;
			}
		}

		function renderParticle(x, y, size, color, opacity) {
			context.fillStyle = "rgba("+ color + "," + opacity + ")";
			context.beginPath();
			context.rect(x*size,y*size,size,size);
			context.fill();
		}

		function load() {
			buildCanvas();
			fillStage();
			animateStage();
		}
		window.onload = load;

	</script>
</body>

</html>